#!/usr/bin/env python
"""
The referi module
"""
import argparse
import os
import importlib
import pygame
import random
from pygame.locals import *
from importlib.util import spec_from_file_location
from definitions.world import world

default_players = tuple(map(
    lambda x:x.split('.')[0],
    filter(
        lambda x:x.endswith('.py'),
        os.listdir('players')
    )
))

def boxes():
    return ((row, col) for row in range(3) for col in range(3))

def is_owned(game):
    # check rows
    for row in range(3):
        if game[row, 0] == None: continue
        if game[row, 0] == game[row, 1]  == game[row, 2]:
            return True
    # check cols
    for col in range(3):
        if game[0, col] == None: continue
        if game[0, col] == game[1, col]  == game[2, col]:
            return True
    # check diagonals
    if game[0, 0] is not None and game[0, 0] == game[1, 1] == game[2, 2]:
        return True
    return game[0, 2] is not None and game[0, 2] == game[1, 1] == game[2, 0]

def is_dead_heat(game):
    # check if there are empty boxes
    filled_boxes = 0
    for row, col in boxes():
        filled_boxes += game[row,col] is not None
    if filled_boxes < 9:
        return False

    # check rows
    for row in range(3):
        if game[row, 0] == game[row, 1]  == game[row, 2]:
            return False
    # check cols
    for col in range(3):
        if game[0, col] == game[1, col]  == game[2, col]:
            return False
    # check diagonals
    if game[0, 0] == game[1, 1] == game[2, 2]:
        return False
    return not (game[0, 2] == game[1, 1] == game[2, 0])

def is_dead_world(world):
    # check if there are empty boxes
    filled_boxes = 0
    for row, col in boxes():
        filled_boxes += world[row,col]['owner'] is not None
    if filled_boxes < 9:
        return False

    # check rows
    for row in range(3):
        if world[row, 0]['owner'] != 'R' and \
           world[row, 0] == world[row, 1]  == world[row, 2]:
            return False
    # check cols
    for col in range(3):
        if world[0, col] != 'R' and \
           world[0, col] == world[1, col]  == world[2, col]:
            return False
    # check diagonals
    if world[0, 0] != 'R' and world[0, 0] == world[1, 1] == world[2, 2]:
        return False
    return world[0, 2] != 'R' and not (world[0, 2] == world[1, 1] == world[2, 0])

def won_game(world):
    # check rows
    for row in range(3):
        if world[row, 0]['owner'] == None: continue
        if world[row, 0]['owner'] == world[row, 1]['owner']  == world[row, 2]['owner']:
            return True
    # check cols
    for col in range(3):
        if world[0, col]['owner'] == None: continue
        if world[0, col]['owner'] == world[1, col]['owner']  == world[2, col]['owner']:
            return True
    # check diagonals
    if world[0, 0]['owner'] is not None and world[0, 0]['owner'] == world[1, 1]['owner'] == world[2, 2]['owner']:
        return True
    return world[0, 2]['owner'] is not None and world[0, 2]['owner'] == world[1, 1]['owner'] == world[2, 0]['owner']

def main(players, fps, coin):
    pygame.init()
    screen = pygame.display.set_mode((395, 395))
    pygame.display.set_caption('Supercat referi')
    clock = pygame.time.Clock()
    board = pygame.image.load('src/board.png')
    icons = {
        "X": pygame.image.load('src/square.png'),
        "O": pygame.image.load('src/circle.png'),
    }
    big_icons = {
        "X": pygame.image.load('src/square_big.png'),
        "O": pygame.image.load('src/circle_big.png'),
        "R": pygame.image.load('src/octo_big.png'),
    }

    print ('Begining the game...')

    assigns = {
        "X": "player1",
        "O": "player2",
    }
    pieces = ["X", "O", "R"]

    if coin and random.choice([0, 1]) == 1:
        print ('Flipping the coin...')
        print ('player2 starts game')
        players.reverse()
        pieces[0], pieces[1] = pieces[1], pieces[0]
    else:
        print ('player1 starts game')

    turn = False
    move = 1
    game_should_play = None
    playing = True

    while True:
        for event in pygame.event.get():
            if event.type == KEYDOWN and event.key == 27:
                # ESC key, exit game
                return
            elif event.type == QUIT:
                # Handles window close button
                return
        if not playing: continue
        # Make the player play
        game, pos = players[turn].play(
            world.copy(),
            game_should_play,
            pieces[turn],
            move,
        )

        # Handle surrenders
        if game is None:
            print ("%s surrenders!"%assigns[pieces[turn]])
            playing = False
            continue

        # Player made an invalid move
        if game_should_play is not None and game_should_play != game:
            print ("%s did not play the game he should!"%assigns[pieces[turn]])
            playing = False
            continue

        if world[game]['owner'] in pieces:
            print ("%s attempted to play in a closed game!"%assigns[pieces[turn]])
            playing = False
            continue

        # Not available boxes
        if world[game][pos] in pieces:
            print ("%a attempted to play an already played box!"%assigns[pieces[turn]])
            playing = False
            continue

        print (move, assigns[pieces[turn]], game, pos)

        # Set the world to the new status
        world[game][pos] = pieces[turn]

        if is_owned(world[game]):
            world[game]['owner'] = pieces[turn]
            print ("%s owned game %s"%(assigns[pieces[turn]], game))

        if is_dead_heat(world[game]):
            world[game]['owner'] = 'R'
            print ("%s killed the heat %s"%(assigns[pieces[turn]], game))

        if won_game(world):
            print ("%s wins!"%assigns[pieces[turn]])
            playing = False

        elif is_dead_world(world):
            print ("Game finished without a winner")
            playing = False

        game_should_play = pos if world[pos]['owner'] is None else None

        # Paint the board
        screen.fill((255, 255, 255))
        screen.blit(board, (0, 0))

        # Paint the game status
        for g_row in range(3):
            for g_col in range(3):
                if world[g_row, g_col]['owner'] in pieces:
                    # draw a big one
                    coordinates = g_row*(105+30) + 10, g_col*(105 + 30) + 10
                    screen.blit(big_icons[world[g_row, g_col]['owner']], coordinates)
                    continue

                for row in range(3):
                    for col in range(3):
                        if world[g_row, g_col][row, col] in pieces:
                            # draw a small one
                            coordinates = g_row*(105+30) + row*(25 + 15) + 10, g_col*(105 + 30) + col*(25 + 15) + 10
                            screen.blit(icons[world[g_row, g_col][row, col]], coordinates)

        pygame.display.flip()

        turn = not turn
        move += 1

        # tick to 1 fps
        clock.tick(fps)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog="referi",
        description='Supercat referi',
        epilog="""
        lets play!
        """
    )
    parser.add_argument(
        'player1',
        metavar='PLAYER',
        type=str,
        help='first player'
    )
    parser.add_argument(
        'player2',
        metavar='PLAYER',
        type=str,
        help='second player'
    )
    parser.add_argument(
        '-f', '--fps',
        metavar='NUM',
        type=int,
        help='fps at with the game should play',
        default=1,
    )
    parser.add_argument(
        '-c', '--coin',
        action='store_true',
        help='should the referi flip a coin?',
        default=False,
    )

    args = parser.parse_args()

    players = [None, None]

    for p in range(2):
        p_spec = getattr(args, 'player%d'%(p+1))
        try:
            if p_spec in default_players:
                players[p] = importlib.import_module('players.' + p_spec)
            elif os.path.isfile(p_spec):
                players[p] = importlib.import_module(p_spec.split('.')[0])
            else:
                print ('Wrong player: player%d'%p)
        except ValueError:
            print ("Error importing player%d"%p)

    if None in players:
        print ('Missing players!')
        exit(1)

    main(players, args.fps, args.coin)
